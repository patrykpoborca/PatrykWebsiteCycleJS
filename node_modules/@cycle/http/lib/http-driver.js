"use strict";

var _require = require("@cycle/core");

var Rx = _require.Rx;

var superagent = require("superagent");

function optionsToSuperagent(_ref) {
  var url = _ref.url;
  var _ref$send = _ref.send;
  var send = _ref$send === undefined ? null : _ref$send;
  var _ref$accept = _ref.accept;
  var accept = _ref$accept === undefined ? null : _ref$accept;
  var _ref$query = _ref.query;
  var query = _ref$query === undefined ? null : _ref$query;
  var _ref$user = _ref.user;
  var user = _ref$user === undefined ? null : _ref$user;
  var _ref$password = _ref.password;
  var password = _ref$password === undefined ? null : _ref$password;
  var _ref$field = _ref.field;
  var field = _ref$field === undefined ? null : _ref$field;
  var _ref$attach = _ref.attach;
  var attach = _ref$attach === undefined ? null : _ref$attach;
  var _ref$withCredentials = _ref.withCredentials;
  var // if valid, should be an array
  withCredentials = _ref$withCredentials === undefined ? false : _ref$withCredentials;
  var _ref$headers = _ref.headers;
  var headers = _ref$headers === undefined ? {} : _ref$headers;
  var _ref$redirects = _ref.redirects;
  var redirects = _ref$redirects === undefined ? 5 : _ref$redirects;
  var _ref$type = _ref.type;
  var type = _ref$type === undefined ? "json" : _ref$type;
  var _ref$method = _ref.method;
  var method = _ref$method === undefined ? "get" : _ref$method;

  if (typeof url !== "string") {
    throw new Error("Please provide a `url` property in the request options.");
  }
  var sanitizedMethod = method.toLowerCase();
  var request = superagent[sanitizedMethod](url);
  if (typeof request.redirects === "function") {
    request = request.redirects(redirects);
  }
  request = request.type(type);
  if (send !== null) {
    request = request.send(send);
  }
  if (accept !== null) {
    request = request.accept(accept);
  }
  if (query !== null) {
    request = request.query(query);
  }
  if (withCredentials) {
    request = request.withCredentials();
  }
  if (user !== null && password !== null) {
    request = request.auth(user, password);
  }
  for (var key in headers) {
    if (headers.hasOwnProperty(key)) {
      request = request.set(key, headers[key]);
    }
  }
  if (field !== null) {
    for (var key in field) {
      if (field.hasOwnProperty(key)) {
        request = request.field(key, field[key]);
      }
    }
  }
  if (attach !== null) {
    for (var i = attach.length - 1; i >= 0; i--) {
      var a = attach[i];
      request = request.attach(a.name, a.path, a.filename);
    }
  }
  return request;
}

function urlToSuperagent(url) {
  return superagent.get(url);
}

function createResponse$(reqOptions) {
  return Rx.Observable.create(function (observer) {
    var request = undefined;
    if (typeof reqOptions === "string") {
      request = urlToSuperagent(reqOptions);
    } else if (typeof reqOptions === "object") {
      request = optionsToSuperagent(reqOptions);
    } else {
      observer.onError(new Error("Observable of requests given to HTTP " + "Driver must emit either URL strings or objects with parameters."));
      return function () {}; // noop
    }

    try {
      request.end(function (err, res) {
        if (err) {
          observer.onError(err);
        } else {
          observer.onNext(res);
          observer.onCompleted();
        }
      });
    } catch (err) {
      observer.onError(err);
    }

    return function onDispose() {
      request.abort();
    };
  });
}

function makeHTTPDriver() {
  var _ref2 = arguments.length <= 0 || arguments[0] === undefined ? { autoSubscribe: true } : arguments[0];

  var _ref2$autoSubscribe = _ref2.autoSubscribe;
  var autoSubscribe = _ref2$autoSubscribe === undefined ? true : _ref2$autoSubscribe;

  return function httpDriver(request$) {
    var response$$ = request$.map(function (reqOptions) {
      var response$ = createResponse$(reqOptions);
      if (autoSubscribe) {
        response$ = response$.replay(null, 1);
        response$.connect();
      }
      response$.request = reqOptions;
      return response$;
    });
    if (autoSubscribe) {
      response$$ = response$$.replay(null, 1);
      response$$.connect();
    }
    return response$$;
  };
}

module.exports = {
  optionsToSuperagent: optionsToSuperagent,
  urlToSuperagent: urlToSuperagent,
  createResponse$: createResponse$,

  makeHTTPDriver: makeHTTPDriver
};