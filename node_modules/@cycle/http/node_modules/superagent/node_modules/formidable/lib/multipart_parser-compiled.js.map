{"version":3,"sources":["multipart_parser.js"],"names":[],"mappings":"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","file":"multipart_parser-compiled.js","sourcesContent":["var Buffer = require('buffer').Buffer,\n    s = 0,\n    S =\n    { PARSER_UNINITIALIZED: s++,\n      START: s++,\n      START_BOUNDARY: s++,\n      HEADER_FIELD_START: s++,\n      HEADER_FIELD: s++,\n      HEADER_VALUE_START: s++,\n      HEADER_VALUE: s++,\n      HEADER_VALUE_ALMOST_DONE: s++,\n      HEADERS_ALMOST_DONE: s++,\n      PART_DATA_START: s++,\n      PART_DATA: s++,\n      PART_END: s++,\n      END: s++\n    },\n\n    f = 1,\n    F =\n    { PART_BOUNDARY: f,\n      LAST_BOUNDARY: f *= 2\n    },\n\n    LF = 10,\n    CR = 13,\n    SPACE = 32,\n    HYPHEN = 45,\n    COLON = 58,\n    A = 97,\n    Z = 122,\n\n    lower = function(c) {\n      return c | 0x20;\n    };\n\nfor (s in S) {\n  exports[s] = S[s];\n}\n\nfunction MultipartParser() {\n  this.boundary = null;\n  this.boundaryChars = null;\n  this.lookbehind = null;\n  this.state = S.PARSER_UNINITIALIZED;\n\n  this.index = null;\n  this.flags = 0;\n};\nexports.MultipartParser = MultipartParser;\n\nMultipartParser.stateToString = function(stateNumber) {\n  for (var state in S) {\n    var number = S[state];\n    if (number === stateNumber) return state;\n  }\n};\n\nMultipartParser.prototype.initWithBoundary = function(str) {\n  this.boundary = new Buffer(str.length+4);\n  this.boundary.write('\\r\\n--', 'ascii', 0);\n  this.boundary.write(str, 'ascii', 4);\n  this.lookbehind = new Buffer(this.boundary.length+8);\n  this.state = S.START;\n\n  this.boundaryChars = {};\n  for (var i = 0; i < this.boundary.length; i++) {\n    this.boundaryChars[this.boundary[i]] = true;\n  }\n};\n\nMultipartParser.prototype.write = function(buffer) {\n  var self = this,\n      i = 0,\n      len = buffer.length,\n      prevIndex = this.index,\n      index = this.index,\n      state = this.state,\n      flags = this.flags,\n      lookbehind = this.lookbehind,\n      boundary = this.boundary,\n      boundaryChars = this.boundaryChars,\n      boundaryLength = this.boundary.length,\n      boundaryEnd = boundaryLength - 1,\n      bufferLength = buffer.length,\n      c,\n      cl,\n\n      mark = function(name) {\n        self[name+'Mark'] = i;\n      },\n      clear = function(name) {\n        delete self[name+'Mark'];\n      },\n      callback = function(name, buffer, start, end) {\n        if (start !== undefined && start === end) {\n          return;\n        }\n\n        var callbackSymbol = 'on'+name.substr(0, 1).toUpperCase()+name.substr(1);\n        if (callbackSymbol in self) {\n          self[callbackSymbol](buffer, start, end);\n        }\n      },\n      dataCallback = function(name, clear) {\n        var markSymbol = name+'Mark';\n        if (!(markSymbol in self)) {\n          return;\n        }\n\n        if (!clear) {\n          callback(name, buffer, self[markSymbol], buffer.length);\n          self[markSymbol] = 0;\n        } else {\n          callback(name, buffer, self[markSymbol], i);\n          delete self[markSymbol];\n        }\n      };\n\n  for (i = 0; i < len; i++) {\n    c = buffer[i];\n    switch (state) {\n      case S.PARSER_UNINITIALIZED:\n        return i;\n      case S.START:\n        index = 0;\n        state = S.START_BOUNDARY;\n      case S.START_BOUNDARY:\n        if (index == boundary.length - 2) {\n          if (c != CR) {\n            return i;\n          }\n          index++;\n          break;\n        } else if (index - 1 == boundary.length - 2) {\n          if (c != LF) {\n            return i;\n          }\n          index = 0;\n          callback('partBegin');\n          state = S.HEADER_FIELD_START;\n          break;\n        }\n\n        if (c != boundary[index+2]) {\n          index = -2;\n        }\n        if (c == boundary[index+2]) {\n          index++;\n        }\n        break;\n      case S.HEADER_FIELD_START:\n        state = S.HEADER_FIELD;\n        mark('headerField');\n        index = 0;\n      case S.HEADER_FIELD:\n        if (c == CR) {\n          clear('headerField');\n          state = S.HEADERS_ALMOST_DONE;\n          break;\n        }\n\n        index++;\n        if (c == HYPHEN) {\n          break;\n        }\n\n        if (c == COLON) {\n          if (index == 1) {\n            // empty header field\n            return i;\n          }\n          dataCallback('headerField', true);\n          state = S.HEADER_VALUE_START;\n          break;\n        }\n\n        cl = lower(c);\n        if (cl < A || cl > Z) {\n          return i;\n        }\n        break;\n      case S.HEADER_VALUE_START:\n        if (c == SPACE) {\n          break;\n        }\n\n        mark('headerValue');\n        state = S.HEADER_VALUE;\n      case S.HEADER_VALUE:\n        if (c == CR) {\n          dataCallback('headerValue', true);\n          callback('headerEnd');\n          state = S.HEADER_VALUE_ALMOST_DONE;\n        }\n        break;\n      case S.HEADER_VALUE_ALMOST_DONE:\n        if (c != LF) {\n          return i;\n        }\n        state = S.HEADER_FIELD_START;\n        break;\n      case S.HEADERS_ALMOST_DONE:\n        if (c != LF) {\n          return i;\n        }\n\n        callback('headersEnd');\n        state = S.PART_DATA_START;\n        break;\n      case S.PART_DATA_START:\n        state = S.PART_DATA;\n        mark('partData');\n      case S.PART_DATA:\n        prevIndex = index;\n\n        if (index == 0) {\n          // boyer-moore derrived algorithm to safely skip non-boundary data\n          i += boundaryEnd;\n          while (i < bufferLength && !(buffer[i] in boundaryChars)) {\n            i += boundaryLength;\n          }\n          i -= boundaryEnd;\n          c = buffer[i];\n        }\n\n        if (index < boundary.length) {\n          if (boundary[index] == c) {\n            if (index == 0) {\n              dataCallback('partData', true);\n            }\n            index++;\n          } else {\n            index = 0;\n          }\n        } else if (index == boundary.length) {\n          index++;\n          if (c == CR) {\n            // CR = part boundary\n            flags |= F.PART_BOUNDARY;\n          } else if (c == HYPHEN) {\n            // HYPHEN = end boundary\n            flags |= F.LAST_BOUNDARY;\n          } else {\n            index = 0;\n          }\n        } else if (index - 1 == boundary.length)  {\n          if (flags & F.PART_BOUNDARY) {\n            index = 0;\n            if (c == LF) {\n              // unset the PART_BOUNDARY flag\n              flags &= ~F.PART_BOUNDARY;\n              callback('partEnd');\n              callback('partBegin');\n              state = S.HEADER_FIELD_START;\n              break;\n            }\n          } else if (flags & F.LAST_BOUNDARY) {\n            if (c == HYPHEN) {\n              callback('partEnd');\n              callback('end');\n              state = S.END;\n            } else {\n              index = 0;\n            }\n          } else {\n            index = 0;\n          }\n        }\n\n        if (index > 0) {\n          // when matching a possible boundary, keep a lookbehind reference\n          // in case it turns out to be a false lead\n          lookbehind[index-1] = c;\n        } else if (prevIndex > 0) {\n          // if our boundary turned out to be rubbish, the captured lookbehind\n          // belongs to partData\n          callback('partData', lookbehind, 0, prevIndex);\n          prevIndex = 0;\n          mark('partData');\n\n          // reconsider the current character even so it interrupted the sequence\n          // it could be the beginning of a new sequence\n          i--;\n        }\n\n        break;\n      case S.END:\n        break;\n      default:\n        return i;\n    }\n  }\n\n  dataCallback('headerField');\n  dataCallback('headerValue');\n  dataCallback('partData');\n\n  this.index = index;\n  this.state = state;\n  this.flags = flags;\n\n  return len;\n};\n\nMultipartParser.prototype.end = function() {\n  var callback = function(self, name) {\n    var callbackSymbol = 'on'+name.substr(0, 1).toUpperCase()+name.substr(1);\n    if (callbackSymbol in self) {\n      self[callbackSymbol]();\n    }\n  };\n  if ((this.state == S.HEADER_FIELD_START && this.index == 0) ||\n      (this.state == S.PART_DATA && this.index == this.boundary.length)) {\n    callback(this, 'partEnd');\n    callback(this, 'end');\n  } else if (this.state != S.END) {\n    return new Error('MultipartParser.end(): stream ended unexpectedly: ' + this.explain());\n  }\n};\n\nMultipartParser.prototype.explain = function() {\n  return 'state = ' + MultipartParser.stateToString(this.state);\n};\n"]}